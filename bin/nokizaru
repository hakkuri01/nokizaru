#!/usr/bin/env ruby
# frozen_string_literal: true

# Set up signal handling before requiring gems so shutdown behavior stays predictable
# Install traps before Bundler can register its own handlers

$stdout.sync = true # Ensure output is flushed immediately
$interrupted = false

# Set up clean interrupt handling for Ctrl+C
Signal.trap('INT') do
  if $interrupted
    # Second Ctrl+C = hard exit
    puts "\n\e[31m⟦✘⟧ Force quit\e[0m"
    exit!(1)
  else
    # First Ctrl+C = graceful shutdown
    $interrupted = true
    puts "\n\e[33m⟦✘⟧ Scan interrupted by user\e[0m"
    puts "\e[2m    Press Ctrl+C again to force quit\e[0m"

    # Kill all threads except main
    Thread.list.each do |thread|
      thread.exit unless thread == Thread.main
    end

    puts "\e[2mCleaning up...\e[0m"
    exit(130)
  end
end

# Handle SIGTERM
Signal.trap('TERM') do
  puts "\n\e[33m⟦✘⟧ Received termination signal\e[0m"
  Thread.list.each { |t| t.exit unless t == Thread.main }
  exit(143)
end

# Normalize CLI arguments before Thor parses them
# Thor does not support multi letter short flags
# Rewrite known short aliases into equivalent long options before parse time
def normalize_argv!(argv)
  replacements = {}
  replacements['-nb'] = '--nb'
  replacements['-dt'] = '--dt'
  replacements['-pt'] = '--pt'
  replacements['-sp'] = '--sp'
  replacements['-cd'] = '--cd'
  replacements['-of'] = '--of'

  argv.map! do |arg|
    if replacements.key?(arg)
      replacements[arg]
    else
      found = replacements.find { |k, _| arg.start_with?(k + '=') }
      if found
        k, v = found
        v + arg[k.length..-1]
      else
        arg
      end
    end
  end
end

# Normalize common help flag patterns to Thor compatible syntax
def normalize_help_invocation!(argv)
  # Thor's canonical help form is: `nokizaru help scan`
  # Many users expect: `nokizaru scan --help`
  # Depending on Thor/version/config, `scan --help` may be treated as a positional argument
  # Normalize common help patterns into `help <command>`

  # Example usage: `nokizaru scan --help` or `nokizaru run --help`
  if argv[0] && %w[scan run].include?(argv[0]) && (argv.include?('--help') || argv.include?('-h'))
    argv.replace(%w[help scan])
    return
  end

  # Example usage: `nokizaru --help scan`
  return unless argv[0] && %w[--help -h].include?(argv[0]) && argv[1] == 'scan'

  argv.replace(%w[help scan])
  nil
end

# Run the main CLI entrypoint with guarded error handling

begin
  # Normalize arguments before Thor processes them
  normalize_help_invocation!(ARGV)
  normalize_argv!(ARGV)

  # Load the application
  require_relative '../lib/nokizaru'

  # Start the CLI
  Nokizaru::CLI.start(ARGV)
rescue Interrupt
  # Catch any Interrupt that bubbles up (shouldn't happen with trap above)
  puts "\n\e[2mExited.\e[0m" unless $interrupted
  exit(130)
rescue SystemExit
  # Allow normal exits to propagate
  raise
rescue StandardError => e
  # Catch any unexpected errors and display them cleanly
  puts "\n\e[31m⟦✘⟧ Unexpected error: #{e.class}\e[0m"
  puts "\e[2m#{e.message}\e[0m"

  # Show backtrace only if in development/debug mode
  if ENV['NOKIZARU_DEBUG'] || ENV['DEBUG']
    puts "\n\e[2mBacktrace:\e[0m"
    puts e.backtrace.map { |line| "  #{line}" }.join("\n")
  else
    puts "\e[2mRun with NOKIZARU_DEBUG=1 for full backtrace\e[0m"
  end

  exit(1)
end
